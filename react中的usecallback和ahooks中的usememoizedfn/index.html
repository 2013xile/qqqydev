<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="沉默入海"><link rel="shortcut icon" href=https://qqqy.dev/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://qqqy.dev/react%E4%B8%AD%E7%9A%84usecallback%E5%92%8Cahooks%E4%B8%AD%E7%9A%84usememoizedfn/><link href=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css rel=stylesheet><script src=https://cdn.bootcdn.net/ajax/libs/highlight.js/11.7.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><title>React中的useCallback和ahooks中的useMemoizedFn</title></head><body><header id=banner><h2><a href=https://qqqy.dev>沉海记</a></h2><nav><ul><li><a href=/categories/ title=categories>categories</a></li><li><a href=/about/ title=about>about</a></li><li><a href=/resume/ title=résumé>résumé</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>React中的useCallback和ahooks中的useMemoizedFn</h1><div><time>September 20, 2023</time></div></header><blockquote><p>应该是一个比较常见的问题了，但是在我这段工作开始之前，我有两三年没有正儿八经写前端了，我的 <code>React</code> 经验还停留在 <code>React 16</code>, 基本上算一个新手，所以记录一下。</p></blockquote><p>事情的起因是我在组件的 <code>useEffect</code> 中依赖了一个外部函数，当函数没有添加到依赖数组时，eslint会报错 &ldquo;mssing dependency&rdquo;.</p><img src=https://s2.loli.net/2023/09/21/CBbOykuAm6VFW7N.png><p>虽然报错级别是 <code>warning</code>, 但是作为一个强迫症，我不能忍啊。啪，很快的，我把这个函数直接就丢到依赖数组里了，这下好了，我发现 <code>useEffect</code> 开始不停地触发。</p><p>这个问题通过搜索，不难找到答案，因为每次函数的地址都会发生修改，导致 <code>useEffect</code> 的依赖数组更新。结合搜索结果，我也很快想起来，有 <code>useCallback</code> 这个东西。但是我发现 <code>useCallback</code> 在我这个场景下好像用不了，因为我这个函数本身是引入的一个外部定义好的函数，放到 <code>useCallback</code> 里还是要求将函数传入依赖数组，不传eslint就会有 <code>warning</code>. 作为一个强迫症，我不能忍啊。</p><p>后面找到解决方法，可以用 <code>useRef</code> 来解决。用 <code>useRef</code> 把这个函数套一下，在 <code>useEffect</code> 里用 <code>ref.current</code> 来调用就可以了，也不会要求传入依赖参数了。</p><p>这个问题到上面就解决完了。但是刚好我们的代码库里是有用到 <a href=https://ahooks.js.org/>ahooks</a>, 有一天我在看文档的时候，发现有一个 <code>useMemoizedFn</code>. 根据文档的描述:</p><blockquote><p>持久化 function 的 Hook，理论上，可以使用 useMemoizedFn 完全代替 useCallback。
在某些场景中，我们需要使用 useCallback 来记住一个函数，但是在第二个参数 deps 变化时，会重新生成函数，导致函数地址变化。
使用 useMemoizedFn，可以省略第二个参数 deps，同时保证函数地址永远不会变化。</p></blockquote><p>这恰恰是用来完美解决我的问题的，于是我就想知道它是怎么实现的，是不是也是通过 <code>useRef</code>. 一看<a href=https://github.com/alibaba/hooks/blob/5412bb719de1666ff2e947dfa3e1d231b7f9746f/packages/hooks/src/useMemoizedFn/index.ts#L12>代码</a>，确实是。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-TypeScript data-lang=TypeScript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>useMemoizedFn</span><span class=p>&lt;</span><span class=nt>T</span> <span class=na>extends</span> <span class=na>noop</span><span class=p>&gt;(</span><span class=nx>fn</span>: <span class=kt>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>isDev</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>isFunction</span><span class=p>(</span><span class=nx>fn</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=sb>`useMemoizedFn expected parameter is a function, got </span><span class=si>${</span><span class=k>typeof</span> <span class=nx>fn</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>fnRef</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;(</span><span class=nx>fn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// why not write `fnRef.current = fn`?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// https://github.com/alibaba/hooks/issues/728
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>fnRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=nx>useMemo</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=nx>fn</span><span class=p>,</span> <span class=p>[</span><span class=nx>fn</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>memoizedFn</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>&lt;</span><span class=nt>PickFunction</span><span class=err>&lt;</span><span class=na>T</span><span class=p>&gt;</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>memoizedFn</span><span class=p>.</span><span class=nx>current</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>memoizedFn</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=p>...</span><span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>fnRef</span><span class=p>.</span><span class=nx>current</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>memoizedFn</span><span class=p>.</span><span class=nx>current</span> <span class=kr>as</span> <span class=nx>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></article><script src=https://giscus.app/client.js data-repo=xilesun/qqqydev data-repo-id=R_kgDOJHBOqg data-category=Comments data-category-id=DIC_kwDOJHBOqs4CXwE5 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></main><footer id=footer>Copyright © 2023 YANG QIA</footer></body></html>